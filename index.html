<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="IreCore : A High Performance Simulator for Fury Warriors.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>IreCore</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/AeanSR/irecore">View on GitHub</a>

          <h1 id="project_title">IreCore</h1>
          <h2 id="project_tagline">A High Performance Simulator for Fury Warriors.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/AeanSR/irecore/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/AeanSR/irecore/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="why-irecore" class="anchor" href="#why-irecore" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why IreCore?</h3>

<p>IreCore is a high performance, event-oriented, heterogeneous simulator written in OpenCL C, models a warrior character with fury spec dealing damage to a single raid boss.</p>

<p>Currently the state-of-the-art simulator <a href="https://github.com/simulationcraft/simc">SimulationCraft</a> is far more functional than IreCore. But while large-scale theorycrafting (e.g. <a href="https://github.com/AeanSR/aplga">APLGA</a> &amp; <a href="https://github.com/AeanSR/climb">Maxima Climb</a>), the effeciency of SimC cannot meet our needs. For example, APLGA runs <strong>billions</strong> of sim iterations to generate APL from scratch, for SimC that means approximately 1000 hours CPU time, 41 days without a break. That seems unacceptable.</p>

<p><img src="http://sim.aean.net/speedup_comp.png" alt="SpeedUp SimC versus IreCore"></p>

<p>With IreCore, the simulation speedup for common configurations skyrocketed 20x relatively, and even faster for simplified configurations. What's more, IreCore is able to run on CPU, or GPU, or whatever compute devices support OpenCL, such as Intel Xeon Phi coprocessors. If you run two IreCore process simutaneously on both CPU and GPU, you would get even 2x more faster.</p>

<p>APLGA needs approximately 50 hours CPU time with IreCore as its evaluation function. If we run on both CPU and GPU, it needs just 1 day to get result. Sounds pretty good.</p>

<h3>
<a id="irecore-philosophy" class="anchor" href="#irecore-philosophy" aria-hidden="true"><span class="octicon octicon-link"></span></a>IreCore Philosophy</h3>

<p>Damage dealing process in World of Warcraft is a <em>Fully Observable Markov Process</em>. That means an APL without internal states (Hereinafter referred to as <em>sAPL</em>) can be one of the optimal policy.</p>

<p>sAPL is a mapping from the state set <em><strong>S</strong></em> to the action set <em><strong>A</strong></em>. So if we are at the same state <em>s</em> at different time <em>t1</em> and <em>t2</em>, we will get exactly the same action <em>a</em> from a sAPL.</p>

<p>So, if we scanned APL at moment <em>t1</em>, and executed nothing, and nothing happened to change system state, at the next moment <em>t2</em> we will execute nothing, same for the next moment <em>t3</em>, and same for the next moment <em>t4</em>... Until something happened and the system state changed, we may get a different action from APL.</p>

<p>Let's see some example. Here stands a warrior "Kylaciela" and she uses a spell called "bump". "bump" has no cooldown, no cost, and have a GCD. We designed a cool policy for Kyla, described as sAPL:</p>

<pre><code>bump, if bump is ready.
otherwise, wait.
</code></pre>

<p>We concluded the system states and actions as something like this:</p>

<pre><code>enum {
    bump_ready,
    bump_not_ready,
} state_set;

enum {
    bump,
    wait,
} action_set;
</code></pre>

<p>And the cool sAPL is a mapping from state set to action set:</p>

<pre><code>bump_ready     -&gt; bump
bump_not_ready -&gt; wait
</code></pre>

<p>Now let's start the simulation. At initial time <code>0:00.000</code>, bump is ready, we scanned the APL and bumped. The state shifted from <code>bump_ready</code> to <code>bump_not_ready</code>, and will shift back to <code>bump_ready</code> at time <code>0:01.500</code>.</p>

<p>Time elapsed. The atomic timespan size of SimC is 31ms, so we arrived at <code>0:00.031</code>, scanned the APL and waited.</p>

<p>Time elapsed. We arrived at <code>0:00.062</code>, scanned and waited.</p>

<p>Time elapsed. We arrived at <code>0:00.093</code>, scanned and waited.</p>

<p>......</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">IreCore maintained by <a href="https://github.com/AeanSR">AeanSR</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
