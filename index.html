<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="IreCore : A High Performance Simulator for Fury Warriors.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>IreCore</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/AeanSR/irecore">View on GitHub</a>

          <h1 id="project_title">IreCore</h1>
          <h2 id="project_tagline">A High Performance Simulator for Fury Warriors.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/AeanSR/irecore/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/AeanSR/irecore/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><a href="http://sim.aean.net/zh-cn.html">切换到中文页面</a></p>

<h3>
<a id="downloads-drivers--runtimes" class="anchor" href="#downloads-drivers--runtimes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Downloads, Drivers &amp; Runtimes</h3>

<p><strong>Get released executable from <a href="https://github.com/AeanSR/irecore/releases/latest">here</a>.</strong></p>

<p>If you are using Intel hardware, get your runtime from <a href="https://software.intel.com/en-us/articles/opencl-drivers">here</a>. If you are using AMD hardware, get your runtime from <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/">here</a>.</p>

<p>Running on GPU is not recommended currently, especially for users of Windows 7 or older operating system. If you want to get GPU support, just install latest graphic card driver from nVidia or AMD.</p>

<p>If you are getting Video Driver Reset when running on GPU, use <a href="https://forums.geforce.com/default/topic/694754/geforce-drivers/tdr-manipulator-v1-1-02-23-2014-/">TDR Manipulator</a> to temporarily disable TDR mechanism of windows, then restart your computer. <strong>It is NOT RECOMMENDED to disable TDR for a long term</strong> since that may cause damage to your hardware.</p>

<h3>
<a id="why-irecore" class="anchor" href="#why-irecore" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why IreCore?</h3>

<p>IreCore is a high performance, event-oriented, heterogeneous simulator written in OpenCL C, models a fury warrior character dealing damage to a single raid boss.</p>

<p>Currently the state-of-the-art simulator <a href="https://github.com/simulationcraft/simc">SimulationCraft</a> is far more functional than IreCore. But while large-scale theorycrafting (e.g. <a href="https://github.com/AeanSR/aplga">APLGA</a> &amp; <a href="https://github.com/AeanSR/climb">Maxima Climb</a>), the effeciency of SimC cannot meet our needs. For example, APLGA runs <strong>billions</strong> of sim iterations to generate APL from scratch, for SimC that means approximately 1000 hours CPU time, 41 days without a break. That seems unacceptable.</p>

<p><img src="http://sim.aean.net/speedup_comp.png" alt="SpeedUp SimC versus IreCore"></p>

<p>With IreCore, the simulation speedup skyrocketed 20x relatively for common configurations, and even higher for simplified configurations. What's more, IreCore is able to run on CPU, or GPU, or whatever compute devices support OpenCL, such as Intel Xeon Phi coprocessors. If you run two IreCore processes simutaneously on both CPU and GPU, you would get even 2x more faster.</p>

<p>APLGA needs approximately 50 hours CPU time with IreCore. If we run on both CPU and GPU, it needs just 1 day to get result. Sounds pretty good.</p>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h3>

<p>IreCore is a console simulator without graphic user interface. All configurations is done by passing parameters to the command line. Extract the release archive into your working directory (e.g. <code>E:\working_dir\</code>), and you will get 5 files and 1 folder.</p>

<ul>
<li>
<strong>irecore.exe</strong>: The simulator frontend. Main executable. </li>
<li>
<strong>kernel.c</strong>: The kernel source. The kernel includes the whole simulator architecture and the fury spec defines. It is loaded dynamically so you can modify it, to achieve your special simulation goal.</li>
<li>
<strong>msvcr120.dll</strong> &amp; <strong>msvcp120.dll</strong>: C++ runtime library. If you already installed 32-bit VC++ 2013 Redistributable, these files is not needed.</li>
<li>
<strong>LICENSE</strong>: IreCore is distributed under the terms of The MIT License, here is a copy of the license.</li>
<li>
<strong>profile\</strong>: There is a completed configuration file in this folder. You can write your own configuration files with reference of it.</li>
</ul>

<p>IreCore is a heterogeneous simulator, so you may want to assign an appropriate compute device (your CPU most of the time) before the simulation start. Run <code>irecore list_available_devices=1</code> to see the list of available compute devices in your computer.</p>

<pre><code>E:\working_dir\&gt;irecore list_available_devices=1
IreCore 612.1-1-g913360 Apr 23 2015

Query available compute devices ...
Platform :NVIDIA CUDA
        Device 0: GeForce GTX 980M
Platform :Intel(R) OpenCL
        Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz
</code></pre>

<p>If you have setup your runtime environment successfully, you should see your CPU &amp; GPU listed. If not, go back to the top of this page, and download your runtime via links given in <strong>Downloads, Drivers &amp; Runtimes</strong>.</p>

<p>When you are ready to start your simulation, add parameter <code>opencl_device_id</code> to the command line to assign a compute device. For example, I want to use CPU as my compute device, and it is listed as "Device 1", so I add <code>opencl_device_id=1</code> into my command line.</p>

<pre><code>E:\working_dir\&gt;irecore opencl_device_id=1 profile\ic_tg_t17m.txt
IreCore 612.1-1-g913360 Apr 23 2015

Query available compute devices ...
Platform :NVIDIA CUDA
        Device 0: GeForce GTX 980M
Platform :Intel(R) OpenCL
        Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz
Execute on Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz
OK!
JIT ...
Sim &lt;unnamed stat set&gt;...
Report for Stat Set &lt;unnamed stat set&gt;
DPS 47504.3
DPS Range(stddev) 1165.6
DPS Error(95% conf.) 10.4255

......
</code></pre>

<p>Now you have your IreCore running on that device, enjoy it!</p>

<h3>
<a id="irecore-philosophy" class="anchor" href="#irecore-philosophy" aria-hidden="true"><span class="octicon octicon-link"></span></a>IreCore Philosophy</h3>

<p>Damage dealing process in World of Warcraft is a <em>Fully Observable Markov Process</em>. That means an APL without internal states (Hereinafter referred to as <em>sAPL</em>) can be one of the optimal policy.</p>

<p>sAPL is a mapping from the state set <em><strong>S</strong></em> to the action set <em><strong>A</strong></em>. So if we are at the same state <em>s</em> at different time <em>t1</em> and <em>t2</em>, we will get exactly the same action <em>a</em> from a sAPL.</p>

<p>So, if we scanned APL at moment <em>t1</em>, and executed nothing, and nothing happened to change system state, at the next moment <em>t2</em> we will execute nothing, same for the next moment <em>t3</em>, and same for the next moment <em>t4</em>... Until something happened and the system state changed, we may get a different action from sAPL.</p>

<p>Let's see some example. Here stands a warrior "Kylaciela" and she uses a spell called "bump". "bump" has no cooldown, no cost, and have a GCD. We designed a cool policy for Kyla, described as sAPL:</p>

<pre><code>bump, if bump is ready.
otherwise, wait.
</code></pre>

<p>We concluded the system states and actions as something like this:</p>

<pre><code>enum {
    bump_ready,
    bump_not_ready,
} state_set;

enum {
    bump,
    wait,
} action_set;
</code></pre>

<p>And the cool sAPL is a mapping from state set to action set:</p>

<pre><code>bump_ready     -&gt; bump
bump_not_ready -&gt; wait
</code></pre>

<p>Now let's start the simulation. At initial time <code>0:00.000</code>, Kyla's bump is ready, we scanned the APL and bumped. The state shifted from <code>bump_ready</code> to <code>bump_not_ready</code>, and will shift back to <code>bump_ready</code> at time <code>0:01.500</code>.</p>

<p>Time elapsed. The atomic timespan size of SimC is 31ms, so we arrived at <code>0:00.031</code>, scanned the APL and waited.</p>

<p>Time elapsed. We arrived at <code>0:00.062</code>, scanned and waited.</p>

<p>Time elapsed. We arrived at <code>0:00.093</code>, scanned and waited.</p>

<p>......</p>

<p>Stupid simulation, lots of cycles wasted on APL scannning. But SimC is brilliant enough to avoid such repeated meaningless APL scanning. SimC will find Kyla is not ready until <code>0:01.500</code>, so the next scanning is directly scheduled at <code>0:01.500</code>.</p>

<p>Time elapsed. We arrived at <code>0:00.031</code> and do nothing.</p>

<p>Time elapsed. We arrived at <code>0:00.062</code>, do nothing.</p>

<p>Time elapsed. We arrived at <code>0:00.093</code>, do nothing.</p>

<p>......</p>

<p>Time elapsed. We arrived at <code>0:01.500</code>, <code>player_ready_event</code> occured, scanned and bumped.</p>

<p>If we already know the next bump may occur at <code>0:01.500</code>, why we have to wait for time elapsing? Have a look at how IreCore deals with Kyla.</p>

<p>At initial time <code>0:00.000</code>, we scanned the APL and APL told us to bump. So a <code>bump_exec</code> event is scheduled at <code>0:00.000</code>, and a <code>gcd_ready</code> event is scheduled at <code>0:01.500</code>. Now we have a event queue looks like:</p>

<pre><code>0:00.000 bump_exec
0:01.500 gcd_ready
7:31.250 simulation_end
</code></pre>

<p><code>bump_exec</code> event is not simply a registered bump, it represents a shifting from state <code>bump_ready</code> to state <code>bump_not_ready</code>. While <code>gcd_ready</code> represents a shifting from <code>bump_not_ready</code> back to <code>bump_ready</code>.</p>

<p>Next step, IreCore takes the first event out of the queue, and try to executes it. Kyla bumped, and no new events scheduled. Now the event queue looks like:</p>

<pre><code>0:01.500 gcd_ready
7:31.250 simulation_end
</code></pre>

<p>Next step, IreCore takes the first event out of the queue, and try to executes it. So the current time is about to <strong>jump</strong> from <code>0:00.000</code> to <code>0:01.500</code>. When time jumps, IreCore scans APL immediately before the jump. APL told us to wait, so the current time jumps to <code>0:01.500</code> and IreCore executes <code>gcd_ready</code>. <code>gcd_ready</code> is just a dummy event, nothing really happened, no new events scheduled. Now the event queue looks like:</p>

<pre><code>7:31.250 simulation_end
</code></pre>

<p>Next step, IreCore takes the first event out of the queue, and try to executes it.</p>

<blockquote>
<p>Wwwww...wait, are you going to end the simulation? Kyla just bumped once!</p>
</blockquote>

<p>Don't worry. The current time is about to <strong>jump</strong> from <code>0:01.500</code> to <code>7:31.250</code>. When time jumps, IreCore scans APL immediately before the jump. APL told us to bump, so <code>bump_exec</code> and <code>gcd_ready</code> event is scheduled again, at <code>0:01.500</code> and <code>0:03:000</code> respectively. Now the event queue looks like:</p>

<pre><code>0:01.500 bump_exec
0:03.000 gcd_ready
7:31.250 simulation_end
</code></pre>

<p>So Kyla will keep bumping, until the expected combat length exceeded (<code>7:31.250</code>).</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">IreCore maintained by <a href="https://github.com/AeanSR">AeanSR</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
