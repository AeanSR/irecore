{"name":"IreCore","tagline":"A High Performance Simulator for Fury Warriors.","body":"### Getting Start\r\nGet released binary from [here](https://github.com/AeanSR/irecore/releases/latest).\r\n\r\nIf you are using Intel hardware, get your runtime from [here](https://software.intel.com/en-us/articles/opencl-drivers). If you are using AMD hardware, get your runtime from [here](http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/).\r\n\r\nRunning on GPU is not recommended currently, especially for users of Windows 7 or older operating system. If you want to get GPU support, just install latest graphic card driver from nVidia or AMD.\r\n\r\nIf you are getting Video Driver Reset when running on GPU, use [TDR Manipulator](https://forums.geforce.com/default/topic/694754/geforce-drivers/tdr-manipulator-v1-1-02-23-2014-/) to temporarily disable TDR mechanism of windows, then restart your computer. **It is NOT RECOMMENDED to disable TDR for a long term** since that may cause damage to your hardware.\r\n\r\n### Why IreCore?\r\nIreCore is a high performance, event-oriented, heterogeneous simulator written in OpenCL C, models a warrior character with fury spec dealing damage to a single raid boss.\r\n\r\nCurrently the state-of-the-art simulator [SimulationCraft](https://github.com/simulationcraft/simc) is far more functional than IreCore. But while large-scale theorycrafting (e.g. [APLGA](https://github.com/AeanSR/aplga) & [Maxima Climb](https://github.com/AeanSR/climb)), the effeciency of SimC cannot meet our needs. For example, APLGA runs **billions** of sim iterations to generate APL from scratch, for SimC that means approximately 1000 hours CPU time, 41 days without a break. That seems unacceptable.\r\n\r\n![SpeedUp SimC versus IreCore](http://sim.aean.net/speedup_comp.png)\r\n\r\nWith IreCore, the simulation speedup for common configurations skyrocketed 20x relatively, and even faster for simplified configurations. What's more, IreCore is able to run on CPU, or GPU, or whatever compute devices support OpenCL, such as Intel Xeon Phi coprocessors. If you run two IreCore process simutaneously on both CPU and GPU, you would get even 2x more faster.\r\n\r\nAPLGA needs approximately 50 hours CPU time with IreCore as its evaluation function. If we run on both CPU and GPU, it needs just 1 day to get result. Sounds pretty good.\r\n\r\n### IreCore Philosophy\r\nDamage dealing process in World of Warcraft is a _Fully Observable Markov Process_. That means an APL without internal states (Hereinafter referred to as _sAPL_) can be one of the optimal policy.\r\n\r\nsAPL is a mapping from the state set _**S**_ to the action set _**A**_. So if we are at the same state _s_ at different time _t1_ and _t2_, we will get exactly the same action _a_ from a sAPL.\r\n\r\nSo, if we scanned APL at moment _t1_, and executed nothing, and nothing happened to change system state, at the next moment _t2_ we will execute nothing, same for the next moment _t3_, and same for the next moment _t4_... Until something happened and the system state changed, we may get a different action from APL.\r\n\r\nLet's see some example. Here stands a warrior \"Kylaciela\" and she uses a spell called \"bump\". \"bump\" has no cooldown, no cost, and have a GCD. We designed a cool policy for Kyla, described as sAPL:\r\n```\r\nbump, if bump is ready.\r\notherwise, wait.\r\n```\r\nWe concluded the system states and actions as something like this:\r\n```\r\nenum {\r\n    bump_ready,\r\n    bump_not_ready,\r\n} state_set;\r\n\r\nenum {\r\n    bump,\r\n    wait,\r\n} action_set;\r\n```\r\nAnd the cool sAPL is a mapping from state set to action set:\r\n```\r\nbump_ready     -> bump\r\nbump_not_ready -> wait\r\n```\r\nNow let's start the simulation. At initial time `0:00.000`, Kyla's bump is ready, we scanned the APL and bumped. The state shifted from `bump_ready` to `bump_not_ready`, and will shift back to `bump_ready` at time `0:01.500`.\r\n\r\nTime elapsed. The atomic timespan size of SimC is 31ms, so we arrived at `0:00.031`, scanned the APL and waited.\r\n\r\nTime elapsed. We arrived at `0:00.062`, scanned and waited.\r\n\r\nTime elapsed. We arrived at `0:00.093`, scanned and waited.\r\n\r\n......\r\n\r\nStupid simulation. But SimC is brilliant enough to avoid such repeated meaningless APL scanning. SimC will find Kyla is not ready until `0:01.500`, so the next scanning is directly scheduled at `0:01.500`.\r\n\r\nTime elapsed. We arrived at `0:00.031` and do nothing.\r\n\r\nTime elapsed. We arrived at `0:00.062`, do nothing.\r\n\r\nTime elapsed. We arrived at `0:00.093`, do nothing.\r\n\r\n......\r\n\r\nTime elapsed. We arrived at `0:01.500`, `player_ready_event` occured, scanned and bumped.\r\n\r\nIf we already know the next bump may occur at `0:01.500`, why we have to wait for time elapsing? Have a look at how IreCore deals with Kyla.\r\n\r\nAt initial time `0:00.000`, we scanned the APL and APL told us to bump. So a `bump_exec` event is scheduled at `0:00.000`, and a `gcd_ready` event is scheduled at `0:01.500`. Now we have a event queue looks like:\r\n```\r\n0:00.000 bump_exec\r\n0:01.500 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\n`bump_exec` event is not simply a registered bump, it represents a shifting from state `bump_ready` to state `bump_not_ready`. While `gcd_ready` represents a shifting from `bump_not_ready` back to `bump_ready`.\r\n\r\nNext step, IreCore takes the nearest event out of the queue, and try to executes it. Kyla bumped, and no new events scheduled. Now the event queue looks like:\r\n```\r\n0:01.500 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\nNext step, IreCore takes the nearest event out of the queue, and try to executes it. So the current time is about to **jump** from `0:00.000` to `0:01.500`. When time jumps, IreCore scans APL immediately before the jump. APL told us to wait, so the current time jumps to `0:01.500` and IreCore executes `gcd_ready`. `gcd_ready` is just a dummy event, nothing really happened, no new events scheduled. Now the event queue looks like:\r\n```\r\n7:31.250 simulation_end\r\n```\r\nNext step, IreCore takes the nearest event out of the queue, and try to executes it.\r\n\r\n> Wwwww...wait, are you going to end the simulation? Kyla just bumped one time!\r\n\r\nDon't worry. The current time is about to **jump** from `0:01.500` to `7:31.250`. When time jumps, IreCore scans APL immediately before the jump. APL told us to bump, so `bump_exec` and `gcd_ready` event is scheduled again, at `0:01.500` and `0:03:000` respectively. Now the event queue looks like:\r\n```\r\n0:01.500 bump_exec\r\n0:03.000 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\nSo Kyla will keep bumping, until the expected combat length exceeded (`7:31.250`).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}