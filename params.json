{"name":"IreCore","tagline":"高性能狂暴战模拟器","body":"[English Version](http://sim.aean.net/)\r\n\r\n### 下载，安装驱动和运行时环境\r\n**从[这里](https://github.com/AeanSR/irecore/releases/latest)下载最新的IreCore可执行程序。**\r\n\r\n如果你使用英特尔硬件，从[这里](https://software.intel.com/en-us/articles/opencl-drivers)下载安装运行时环境。如果你使用AMD硬件，从[这里](http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/)下载安装运行时环境。\r\n\r\n目前不建议在GPU上执行IreCore，特别是对于仍在使用Windows 7或者更早版本操作系统的用户来说。如果你想开启GPU运算支持，从英伟达或AMD处获取最新的显卡驱动即可。\r\n\r\n如果在GPU上执行IreCore时出现错误“显示器驱动程序已停止响应，并且已恢复”，使用[TDR Manipulator](https://forums.geforce.com/default/topic/694754/geforce-drivers/tdr-manipulator-v1-1-02-23-2014-/)暂时关闭Windows的TDR机制，然后重新启动。TDR是一种硬件保护机制，**请不要长期关闭TDR**否则有可能对硬件造成损害。\r\n\r\n### 为什么选择IreCore？\r\nIreCore是一个高性能、面向事件异构模拟器，采用OpenCL C编写，模拟一个狂暴战对单个团队副本首领进行输出的过程。\r\n\r\n目前最好的模拟器[SimulationCraft](https://github.com/simulationcraft/simc)的功能比IreCore完善得多。但在大规模理论研究应用当中（例如[APLGA](https://github.com/AeanSR/aplga)和[Maxima Climb](https://github.com/AeanSR/climb)），SimC的效率就无法满足我们的需求了。举例说明，APLGA需要运行**数十亿计**的模拟运算来实现APL自动生成和优化，对于SimC来说这大概需要1000小时的CPU时间，需要连续不间断运行41天。这是难以接受的。\r\n\r\n![SpeedUp SimC versus IreCore](http://sim.aean.net/speedup_comp.png)\r\n\r\n有了IreCore，对于通常的角色配置模拟加速比提升了20倍，对于简化后的角色配置还能提升更多。另外，IreCore能够在CPU或GPU或任何支持OpenCL的计算设备上运行，例如英特尔至强融核协处理器。如果你同时开启两个IreCore进程，分别在CPU和GPU上运行，运算速度会再提高大约一倍。\r\n\r\n使用IreCore之后APLGA大约需要50小时CPU时间。如果我们同时使用CPU和GPU，大约1天的时间就可以得到结果，这样就显得好多了。\r\n\r\n### 初次接触\r\nIreCore是一个命令行模拟器，没有图形界面，所有的配置都是通过向命令行当中传递参数来完成的。将下载的文档解压到工作目录（比如`E:\\working_dir\\`），你会得到5个文件和1个文件夹。\r\n\r\n* **irecore.exe**: 模拟器前端，主程序。\r\n* **kernel.c**: 内核源码。内核包括了整个模拟器架构以及狂暴专精的模型描述。内核是动态加载的所以你可以直接修改它，来完成一些特殊的模拟任务。\r\n* **msvcr120.dll** & **msvcp120.dll**: C++运行时链接库。如果你已经安装了32位 VC++ 2013 Redistributable，就不再需要这些文件。\r\n* **LICENSE**: IreCore的著作权遵循MIT许可协议进行授予，这是许可协议的一份拷贝。\r\n* **profile\\**: 这个文件夹中有一份已经完成的配置文件，你可以参照它来写你自己的配置文件。\r\n\r\nIreCore是一个异构模拟器，所以在开始模拟之前，你可能希望指派一个合适的计算设备（大多数时候是你的CPU）。运行 `irecore list_available_devices=1` 查看你的计算机中当前可用的计算设备列表。\r\n```\r\nE:\\working_dir\\>irecore list_available_devices=1\r\nIreCore 612.1-1-g913360 Apr 23 2015\r\n\r\nQuery available compute devices ...\r\nPlatform :NVIDIA CUDA\r\n        Device 0: GeForce GTX 980M\r\nPlatform :Intel(R) OpenCL\r\n        Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz\r\n```\r\n如果你已经设置好了运行时环境，你应该能够看到你的CPU和GPU。如果没有，请回到页面顶端，在**下载，安装驱动和运行时环境**部分给出了各个设备制造商的运行时下载链接。\r\n\r\n当你准备好开始模拟的时候，将 `opencl_device_id` 参数加入命令行，来指派计算设备。例如，我希望使用CPU进行计算，CPU被列为“Device 1”，所以我在命令行中加入 `opencl_device_id=1` 。\r\n```\r\nE:\\working_dir\\>irecore opencl_device_id=1 profile\\ic_tg_t17m.txt\r\nIreCore 612.1-1-g913360 Apr 23 2015\r\n\r\nQuery available compute devices ...\r\nPlatform :NVIDIA CUDA\r\n        Device 0: GeForce GTX 980M\r\nPlatform :Intel(R) OpenCL\r\n        Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz\r\nExecute on Device 1: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz\r\nOK!\r\nJIT ...\r\nSim <unnamed stat set>...\r\nReport for Stat Set <unnamed stat set>\r\nDPS 47504.3\r\nDPS Range(stddev) 1165.6\r\nDPS Error(95% conf.) 10.4255\r\n\r\n......\r\n```\r\n现在IreCore已经执行在你指定的设备上了，祝你好运！\r\n\r\n### IreCore的智慧\r\n魔兽世界当中的伤害输出过程是一个_完全可观测马氏过程_，这意味着不包含内部状态量的APL（以下简称 _sAPL_）可以成为最优策略之一。\r\n\r\nsAPL本质上是从系统的状态集合_**S**_到动作集合_**A**_的一个映射。所以如果我们在不同的时间_t1_和_t2_处于相同的状态_s_，我们会从sAPL当中得到相同的动作_a_。\r\n\r\n那么，如果我们在_t1_时刻扫描了APL，但是什么动作也没做（APL让我们等待），而且什么事件都没发生，系统的状态不变，那么在下一时刻_t2_我们还是什么动作也不会做，再下一时刻_t3_也一样，_t4_也一样……直到发生了能够改变系统状态的事件，我们才有可能从sAPL当中获得一个不同的动作。\r\n\r\n说点具体的。这有个战士“凯拉希雅”，她会用一个技能，叫做“大挽尊术”。\"大挽尊术\"没有冷却，没有消耗，但是有GCD。于是我们为凯拉设计了一个叼炸天的策略，用sAPL描述是这样的：\r\n```\r\n顶，如果可以顶。\r\n否则等待。\r\n```\r\n我们将系统的状态和动作归结如下：\r\n```\r\nenum {\r\n    可以顶,\r\n    不可以顶,\r\n} 状态集合;\r\n\r\nenum {\r\n    顶,\r\n    等,\r\n} 动作集合;\r\n```\r\n于是这个叼炸天的sAPL可以表示为从状态集合到动作集合的一个映射：\r\n```\r\n可以顶     -> 顶\r\n不可以顶   -> 等\r\n```\r\n好了，我们开始模拟吧。在初始时刻 `0:00.000` ，凯拉的可以顶，我们扫描了APL然后顶了一把。系统状态由 `可以顶` 转移到了 `不可以顶`，而且会在 `0:01.500` 的时候转移回到 `可以顶` 上来。\r\n\r\n时间流逝。SimC设定的原子时间片大小是31毫秒，所以我们现在来到了 `0:00.031`，扫描了APL，然后等待。\r\n\r\n时间流逝。我们现在来到了 `0:00.062`，扫描了APL，然后等待。\r\n\r\n时间流逝。我们现在来到了 `0:00.093`，扫描了APL，然后等待。\r\n\r\n......\r\n\r\n真是脑残的模拟啊，好多时钟周期都浪费在了APL扫描上。但是SimC是足够聪明的，它可以避免这种反复无意义的APL扫描。SimC会发现凯拉直到 `0:01.500` 之前都在转GCD，所以下一次扫描会被直接安排在 `0:01.500`。\r\n\r\n时间流逝。我们现在来到了 `0:00.031`，什么也没做。\r\n\r\n时间流逝。我们现在来到了 `0:00.062`，什么也没做。\r\n\r\n时间流逝。我们现在来到了 `0:00.093`，什么也没做。\r\n\r\n......\r\n\r\n时间流逝。我们现在来到了 `0:01.500`， `player_ready_event` 触发，扫描了APL，顶。\r\n\r\n我们已经知道下一次挽尊可能会在 `0:01.500`，为什么还要等时间慢慢流逝？来看看IreCore是怎么处理的。\r\n\r\n在初始时刻 `0:00.000`，我们扫描了APL，APL告诉我们现在就顶。于是一个 `bump_exec` 事件被安排在了 `0:00.000`，还有一个 `gcd_ready` 事件被安排在了 `0:01.500`。现在我们有一个这样的事件队列：\r\n```\r\n0:00.000 bump_exec\r\n0:01.500 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\n`bump_exec` 事件不单单只是顶一下，它代表了系统从 `可以顶` 到 `不可以顶` 的状态转移。 `gcd_ready` 则代表了从 `不可以顶` 回到 `可以顶` 的状态转移。\r\n\r\n接下来，IreCore将第一个事件取出，然后尝试执行它。于是凯拉顶了一下。没有新的事件安排。现在事件队列是这样的：\r\n```\r\n0:01.500 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\n接下来，IreCore将第一个事件取出，然后尝试执行它。所以当前时间将要从 `0:00.000` **越变** 到 `0:01.500`。每当时间发生越变之前，IreCore立即执行一次APL扫描。APL让我们等待，于是时间越变到 `0:01.500` 然后IreCore执行了事件 `gcd_ready`。 `gcd_ready` 是一个傀儡事件，实际上什么都没有发生，也没有新的事件安排。现在事件队列是这样的：\r\n```\r\n7:31.250 simulation_end\r\n```\r\n接下来，IreCore将第一个事件取出，然后尝试执行它。\r\n\r\n> 等等……你就这样打算结束模拟了？凯拉刚顶了一下啊。\r\n\r\n别着急。当前时间将要从 `0:01.500` **越变** 到 `7:31.250`。每当时间发生越变之前，IreCore立即执行一次APL扫描。APL让我们顶，于是一组新的 `bump_exec` 和 `gcd_ready` 事件又一次被安排进来，分别位于 `0:01.500` 和 `0:03:000`。现在事件队列是这样的：\r\n```\r\n0:01.500 bump_exec\r\n0:03.000 gcd_ready\r\n7:31.250 simulation_end\r\n```\r\n如此反复，凯拉就会不停地顶顶顶，直到预期的战斗时间结束（`7:31.250`）。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}